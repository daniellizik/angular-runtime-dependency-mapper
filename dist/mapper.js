'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _parse = require('parse5');

var _esprima = require('esprima');

var _escodegen = require('escodegen');

var _deepsearch = require('./deepsearch');

var _deepsearch2 = _interopRequireDefault(_deepsearch);

var _traverse = require('./traverse');

var _traverse2 = _interopRequireDefault(_traverse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * entry point for dependency mapper
 * @param {object} angular - angular object
 * @param {array<string>} modules - list of module names to analyze
 * @param {regex} dependencyFilter - filter to exclude 3rd party dependencies
 * @return {array} list of application dependencies
 */
exports.default = function (angular, modules, dependencyFilter) {
  return new Promise(function (resolve, reject) {
    var dependencies = modules.reduce(function (acc, moduleName) {
      return reduceModules(acc, moduleName, angular, dependencyFilter);
    }, []).map(mapDependencies).map(mapDependers);
    resolve(dependencies);
  });
};

/**
 * reduce callback
 * @param {array} acc - accumulator, should be array of objects
 * @param {string} moduleName - name of angular module
 * @return {array} reduce accumulator
 */


function reduceModules(acc, moduleName, angular, dependencyFilter) {
  var _angular$module = angular.module(moduleName),
      _invokeQueue = _angular$module._invokeQueue,
      _configBlocks = _angular$module._configBlocks,
      _runBlocks = _angular$module._runBlocks,
      requires = _angular$module.requires;

  var configBlocks = _configBlocks.reduce(function (list, args) {
    var res = reduceConfigBlocks(moduleName, 'config', args[2][0]);
    return res ? [].concat(_toConsumableArray(list), [res]) : list;
  }, []);
  var invokes = _invokeQueue.reduce(function (list, args) {
    var res = reduceInvokeQueue(moduleName, args[1], args[2][0], args[2]);
    return res ? [].concat(_toConsumableArray(list), [res]) : list;
  }, []);
  // each required module can be used with angular.module() to get nested dependency tree
  var moduleDependencies = requires.filter(function (name) {
    return dependencyFilter.test(name);
  }).reduce(function (list, dependencyName) {
    return reduceModules(list, dependencyName, angular, dependencyFilter);
  }, []);
  return [].concat(_toConsumableArray(acc), _toConsumableArray(configBlocks), _toConsumableArray(invokes), _toConsumableArray(moduleDependencies));
}

/**
 * map callback
 * @param {object} obj - generated from reduceModules
 * @param {number} index - position from list generated by reduceModules
 * @param {array} list - reduceModules return array
 * @return {object} object with dependency array, each item in array is list array index
 */
function mapDependencies(obj, index, list) {
  if (/component|directive/.test(obj.type)) {
    // todo: if templateUrl, Promise.props request and then parse response
    var htmlAst = (0, _parse.parse)(obj.definition.template);
    // for each node, find matching elements by index in entire list
    var dependencies = (0, _traverse2.default)(htmlAst)(function (acc, node) {
      // need to match nodename for restrict E
      var nodeName = node.nodeName.toLowerCase().replace(/-/g, '');
      // or filters attrs for restrict A
      var attrKeys = (node.attrs || []).map(function (a) {
        return a.name.toLowerCase().replace(/-/g, '');
      });
      var mappedIndices = list.reduce(function (acc, o, i) {
        // run, config, value, etc. are not registered with a name
        var componentName = (o.name || '').toLowerCase();
        var hasDependency = nodeName === componentName || attrKeys.indexOf(componentName) > -1;
        return hasDependency ? [].concat(_toConsumableArray(acc), [i]) : acc;
      }, []);
      return [].concat(_toConsumableArray(acc), _toConsumableArray(mappedIndices));
    });
    return _extends({}, obj, { dependencies: dependencies });
  } else {
    return obj;
  }
}

/**
 * goes back through list and maps depender objects
 * @param {object} obj - generated from reduceModules
 * @param {number} index - position from list generated by reduceModules
 * @param {array} list - reduceModules return array
 * @return {object} object with dependers array, each item in array is list array index
 */
function mapDependers(obj, index, list) {
  var dependers = list.reduce(function (acc, o, i) {
    var isDependedOn = (o.dependencies || []).indexOf(index) > -1;
    return !isDependedOn ? acc : [].concat(_toConsumableArray(acc), [i]);
  }, []);
  return _extends({}, obj, { dependers: dependers });
}

/**
 * Finds all registered angular services for given module
 *
 * @param {string} moduleName - name of module
 * @param {string} type - type of service
 * @param {name} type - name of service
 * @param {arguments} ...args - original arguments supplied to service
 * @return {array} list of services registered to module
 *   @property {string} module - name of parent module
 *   @property {string} type - type of angular service
 *   @property {string} definition - config function definition
 */

// todo: this needs to be single obj in array, but have multiple definitions
function reduceConfigBlocks(moduleName, type, definition) {
  var templateRegex = /^template(url)?$/i;
  var ast = (0, _esprima.parse)(definition.toString());
  var stub = (0, _deepsearch2.default)(ast)(function (node) {
    if (node) {
      // todo: too optimistic, user might be defining via dot notation
      if (node.type === 'ObjectExpression') {
        if (node.properties.find(function (n) {
          return templateRegex.test(n.key.name);
        })) {
          return node;
        }
      }
    }
  });
  // ehhh....
  var code = !stub ? {} : new Function('return ' + (0, _escodegen.generate)(stub))();
  return { module: moduleName, type: type, definition: code };
}

/**
 * Finds all registered angular services for given module
 *
 * @param {string} moduleName - name of module
 * @param {string} type - type of service
 * @param {name} type - name of service
 * @param {arguments} ...args - original arguments supplied to service
 * @return {array} list of services registered to module
 *   @property {string} module - name of parent module
 *   @property {string} type - type of angular service
 *   @property {string} name - name of the service
 *   @property {string} definition - if component, directive, or value, the returned object literal
 */
function reduceInvokeQueue(moduleName, type, name) {
  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var definition = args[0][1];
  var base = { type: type, name: name, module: moduleName };
  var isComponent = type === 'component';
  var isDirective = type === 'directive';
  if (isComponent) return _extends({}, base, { definition: definition });else if (isDirective && typeof definition === 'function') return _extends({}, base, { definition: definition() });else if (isDirective && definition.length === 1) return _extends({}, base, { definition: definition[0]() });else if (isDirective && definition.length > 1) return _extends({}, base, { definition: definition.slice(-1).pop()(definition.slice(0, -1)) });
}
//# sourceMappingURL=mapper.js.map