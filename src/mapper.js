import { parse as parseHtml } from 'parse5'
import { parse as parseJs } from 'esprima'
import { generate } from 'escodegen'
import deepsearch from './deepsearch'
import traverse from './traverse'

/**
 * entry point for dependency mapper
 * @param {object} angular - angular object
 * @param {array<string>} modules - list of module names to analyze
 * @param {regex} dependencyFilter - filter to exclude 3rd party dependencies
 * @return {array} list of application dependencies
 */
export default (angular, modules, dependencyFilter) => new Promise((resolve, reject) => {
  const dependencies = modules
    .reduce((acc, moduleName) => reduceModules(acc, moduleName, angular, dependencyFilter), [])
    .map(mapDependencies)
    .map(mapDependers)
  resolve(dependencies)
})

/**
 * reduce callback
 * @param {array} acc - accumulator, should be array of objects
 * @param {string} moduleName - name of angular module
 * @return {array} reduce accumulator
 */
function reduceModules(acc, moduleName, angular, dependencyFilter = /./g) {
  const { _invokeQueue, _configBlocks, _runBlocks, requires } = angular.module(moduleName)
  const configBlocks = _configBlocks.reduce((list, args) => {
    const res = reduceConfigBlocks(moduleName, 'config', args[2][0])
    return res ? [ ...list, res ] : list
  }, [])
  const invokes = _invokeQueue.reduce((list, args) => {
    const res = reduceInvokeQueue(moduleName, args[1], args[2][0], args[2])
    return res ? [ ...list, res ] : list
  }, [])
  // each required module can be used with angular.module() to get nested dependency tree
  const moduleDependencies = requires
    .filter(name => dependencyFilter.test(name))
    .reduce((list, dependencyName) => reduceModules(list, dependencyName, angular, dependencyFilter), [])
  return [
    ...acc,
    ...configBlocks,
    ...invokes,
    ...moduleDependencies
  ]
}

/**
 * map callback
 * @param {object} obj - generated from reduceModules
 * @param {number} index - position from list generated by reduceModules
 * @param {array} list - reduceModules return array
 * @return {object} object with dependency array, each item in array is list array index
 */
function mapDependencies(obj, index, list) {
  if (/component|directive/.test(obj.type)) {
    // todo: if templateUrl, Promise.props request and then parse response
    const htmlAst = parseHtml(obj.definition.template)
    // for each node, find matching elements by index in entire list
    const dependencies = traverse(htmlAst)((acc, node) => {
      // need to match nodename for restrict E
      const nodeName = node.nodeName.toLowerCase().replace(/-/g, '')
      // or filters attrs for restrict A
      const attrKeys = (node.attrs || []).map(a => a.name.toLowerCase().replace(/-/g, ''))
      const mappedIndices = list.reduce((acc, o, i) => {
        // run, config, value, etc. are not registered with a name
        const componentName = (o.name || '').toLowerCase()
        const hasDependency = nodeName === componentName || attrKeys.indexOf(componentName) > -1
        return hasDependency ? [ ...acc, i ] : acc
      }, [])
      return [ ...acc, ...mappedIndices ]
    })
    return { ...obj, dependencies }
  } else {
    return obj
  }
}

/**
 * goes back through list and maps depender objects
 * @param {object} obj - generated from reduceModules
 * @param {number} index - position from list generated by reduceModules
 * @param {array} list - reduceModules return array
 * @return {object} object with dependers array, each item in array is list array index
 */
function mapDependers(obj, index, list) {
  const dependers = list.reduce((acc, o, i) => {
    const isDependedOn = (o.dependencies || []).indexOf(index) > -1
    return !isDependedOn ? acc : [ ...acc, i]
  }, [])
  return { ...obj, dependers }
}

/**
 * Finds all registered angular services for given module
 *
 * @param {string} moduleName - name of module
 * @param {string} type - type of service
 * @param {name} type - name of service
 * @param {arguments} ...args - original arguments supplied to service
 * @return {array} list of services registered to module
 *   @property {string} module - name of parent module
 *   @property {string} type - type of angular service
 *   @property {string} definition - config function definition
 */

// todo: this needs to be single obj in array, but have multiple definitions
function reduceConfigBlocks(moduleName, type, definition) {
  const templateRegex = /^template(url)?$/i
  const ast = parseJs(definition.toString())
  const stub = deepsearch(ast)((node) => {
    if (node) {
      // todo: too optimistic, user might be defining via dot notation
      if (node.type === 'ObjectExpression') {
        if (node.properties.find(n => templateRegex.test(n.key.name))) {
          return node
        }
      }
    }
  })
  // ehhh....
  const code = !stub ? {} : new Function(`return ${generate(stub)}`)()
  return { module: moduleName, type, definition: code }
}

/**
 * Finds all registered angular services for given module
 *
 * @param {string} moduleName - name of module
 * @param {string} type - type of service
 * @param {name} type - name of service
 * @param {arguments} ...args - original arguments supplied to service
 * @return {array} list of services registered to module
 *   @property {string} module - name of parent module
 *   @property {string} type - type of angular service
 *   @property {string} name - name of the service
 *   @property {string} definition - if component, directive, or value, the returned object literal
 */
function reduceInvokeQueue(moduleName, type, name, ...args) {
  const definition = args[0][1]
  const base = { type, name, module: moduleName }
  const isComponent = type === 'component'
  const isDirective = type === 'directive'
  if (isComponent)
    return { ...base, definition }
  else if (isDirective && typeof definition === 'function')
    return { ...base, definition: definition() }
  else if (isDirective && definition.length === 1)
    return { ...base, definition: definition[0]() }
  else if (isDirective && definition.length > 1)
    return { ...base, definition: definition.slice(-1).pop()(definition.slice(0, -1)) }
}
